#!/usr/bin/env ruby
# frozen_string_literal: true

mruby = RUBY_ENGINE == "mruby"

begin
  unless mruby
    begin
      require_relative "../.env"
    rescue LoadError
    end

    require "net/http"
    require "json"
  end

  unless (token = ENV["UBI_TOKEN"])
    $stderr.puts "Personal access token must be provided in UBI_TOKEN env variable for use"
    exit 1
  end

  url = ENV["UBI_URL"] || "https://api.ubicloud.com/cli"
  allowed_progs = %w[ssh scp sftp psql pg_dump pg_dumpall]

  get_prog = lambda do |prog|
    return unless allowed_progs.include?(prog)
    ENV["UBI_#{prog.upcase}"] || prog
  end

  uri = URI(url) unless mruby
  argv = ARGV
  headers = {
    "authorization" => "Bearer: #{token}",
    "content-type" => "application/json",
    "accept" => "text/plain",
    "connection" => "close"
  }
  confirmation_prompt = false
  confirmation = nil

  1.times do
    if ENV["UBI_DEBUG"] == "1"
      p [:sending, *ARGV]
    end

    response = (mruby ? Curl : Net::HTTP).post((mruby ? url : uri), {"argv" => argv}.to_json, headers)

    if mruby
      code = response.status_code
      response.headers
    else
      code = response.code.to_i
      headers = response.header.to_hash
    end

    case code
    when 200...300
      if (prog_type = headers["ubi-command-execute"])
        unless ARGV.include?(prog_type)
          $stderr.puts "! Invalid server response, not executing program not in original argv"
          exit 1
        end

        unless (prog = get_prog[prog_type])
          $stderr.puts "! Invalid server response, unsupported program requested"
          exit 1
        end

        argv_set = ARGV.to_set

        args = response.body.split("\0")
        invalid_message = nil
        sep_seen = false
        custom_arg_seen = false
        pg_dumpall = false

        args.each do |arg|
          if arg == "--"
            sep_seen = true
          elsif !argv_set.include?(arg)
            if custom_arg_seen
              invalid_message = "! Invalid server response, multiple arguments not in submitted argv"
              break
            elsif sep_seen
              custom_arg_seen = true
            elsif prog_type == "pg_dumpall" && arg.start_with?("-d")
              pg_dumpall = true
              custom_arg_seen = true
            else
              invalid_message = "! Invalid server response, argument before '--' not in submitted argv"
              break
            end
          end
        end

        unless sep_seen || pg_dumpall
          invalid_message = "! Invalid server response, no '--' in returned argv"
        end

        if invalid_message
          if ENV["UBI_DEBUG"] == "1"
            p [:failure, prog, *args]
          end
          $stderr.puts invalid_message
          exit 1
        else
          if ENV["UBI_DEBUG"] == "1"
            p [:exec, prog, *args]
          end
          Process.exec(prog, *args)
        end
      else
        if (confirmation_prompt = headers["ubi-confirm"])
          if confirmation
            $stderr.puts "! Invalid server response, repeated confirmation attempt"
            exit 1
          else
            $stdout.puts response.body
            $stdout.print "\n#{confirmation_prompt}: "
            confirmation = $stdin.readline.chomp
            argv.unshift(confirmation)
            argv.unshift("--confirm")
            redo
          end
        else
          $stdout.puts response.body
        end
        exit 0
      end
    else
      $stderr.puts response.body
      exit 1
    end
  end
rescue SystemExit
  raise
# rubocop:disable Lint/RescueException
rescue Exception => e
  # rubocop:enable Lint/RescueException
  # This is needed to get error reporting in mruby, which does not print
  # exceptions by default.
  $stderr.puts "Unhandled Exception: #{e.class}: #{e.message}" if mruby
  raise
end
